import logging
from typing import Any, Dict

import pandas as pd
import requests
import streamlit as st
from dotenv import dotenv_values

import data.cfg as cfg
import analyse
import utils


class SleepDataFrontend:
    """
    SleepDataFrontend provides a Streamlit-based UI for:
    - Cleaning the data through an API call.
    - Displaying sections of content and graphs.
    - Submitting new user data to the backend.
    """

    def __init__(self) -> None:
        """
        Initialize the frontend by setting up logging and running the application.
        """
        self.logger: logging.Logger = None
        self.setup_logging()
        self.run()

    def setup_logging(self) -> None:
        """
        Set up basic logging configuration and logger instance.
        """
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

    @staticmethod
    @st.cache_data
    def load_data() -> pd.DataFrame:
        """
        Load data from the CSV file.

        Returns:
            pd.DataFrame: The loaded DataFrame.
        """
        data_path = dotenv_values('.env')['PATH']
        try:
            data: pd.DataFrame = pd.read_csv(data_path)
            return data
        except FileNotFoundError:
            st.error(f"Data file not found at path: {data_path}")
            return pd.DataFrame()
        except Exception as e:
            st.error(f"An error occuered while loading data: {e}")
            return pd.DataFrame()    
        

    def clean_data(self) -> None:
        """
        Trigger the data cleaning process by calling the backend API.
        """
        try:
            response: requests.Response = requests.get(cfg.CLEAN_DATA_URL)
            if response.status_code == 200:
                self.logger.info("Data successfully cleared.")
                st.success("Data successfully cleared.")
            else:
                self.logger.error("An error occurred while cleaning data.")
                st.error("An error occurred while cleaning data.")
        except requests.exceptions.RequestException as e:
            self.logger.error(f"An error occurred while connecting to the server: {e}")
            st.error("An error occurred while connecting to the server.")

    def display_content(self, graph_generator: analyse.GenerateGraph) -> None:
        """
        Display the main content sections, including graphs generated by given methods.

        Args:
            graph_generator (analyse.GenerateGraph): An instance used to generate graphs.
        """
        st.title("Sleep Statistics")

        self.clean_data()

        file_to_parse_path: str = dotenv_values('.env')['PATH_TO_PARSE']
        utils_obj: utils.Utils = utils.Utils(file_to_parse_path)
        content_blocks = utils_obj.parse_file()

        section_titles = []
        sections_content = []
        current_section_blocks = []

        for block_type, block_content in content_blocks:
            if block_type == 'title':
                if current_section_blocks:
                    sections_content.append(current_section_blocks)
                    current_section_blocks = []
                section_titles.append(block_content.strip())
            else:
                current_section_blocks.append((block_type, block_content))

        if current_section_blocks:
            sections_content.append(current_section_blocks)

        
        section_titles.append(cfg.form_title)
        sections_content.append([])

        st.sidebar.title('Navigation')

        selected_section = st.sidebar.radio("GO TO", section_titles)

        for title, blocks in zip(section_titles, sections_content):
            if title == cfg.form_title:
                self.display_form()
            elif title == selected_section:
                for block_type, block_content in blocks:
                    if block_type == 'text':
                        st.markdown(block_content)
                    elif block_type == 'method':
                        method_name: str = block_content.strip()
                        if hasattr(graph_generator, method_name):
                            method = getattr(graph_generator, method_name)
                            if callable(method):
                                try:
                                    fig = method()
                                    if fig:
                                        st.plotly_chart(fig, use_container_width=True, key=utils_obj.generate_key())
                                    else:
                                        st.error(f"Method '{method_name}' returned None.")
                                except Exception as e:
                                    st.error(f"Error while calling '{method_name}': {e}")
                                    self.logger.error(f"Error while calling '{method_name}': {e}")
                            else:
                                st.error(f"'{method_name}' is not callable.")
                        else:
                            st.error(f"Method '{method_name}' not found.")
                    elif block_type == 'code':
                        with st.expander("Show/Close code"):
                            st.code(block_content)
                break

    def display_form(self) -> None:
        """
        Display a form allowing the user to submit new sleep-related data.
        """
        st.header("Add your own data to analyze it.")
        with st.form("sleep_form"):
            gender: str = st.selectbox("Gender", ["Male", "Female"])
            age: int = st.number_input("Age (18-60)", min_value=18, max_value=60, step=1)
            occupation: str = st.text_input("Occupation:")
            sleep_duration: float = st.slider("Sleep duration (in hours)", min_value=2.0, max_value=12.0, step=0.1)
            quality_of_sleep: int = st.slider("Quality of sleep", min_value=0, max_value=10, step=1)
            stress_level: int = st.slider("Stress level", min_value=0, max_value=10, step=1)
            physical_activity_level: int = st.slider("Physical activity level", min_value=0, max_value=100, step=5)

            submitted: bool = st.form_submit_button("Submit")

        if submitted:
            if occupation.strip() == '':
                occupation = 'Unemployed'

            submission_data: Dict[str, Any] = {
                "gender": gender,
                "age": age,
                "occupation": occupation,
                "sleep_duration": sleep_duration,
                "quality_of_sleep": quality_of_sleep,
                "physical_activity_level": physical_activity_level,
                "stress_level": stress_level,
            }
            self.handle_submission(submission_data)
            self.handle_prediction(submission_data)

    def handle_submission(self, submission_data: Dict[str, Any]) -> None:
        """
        Handle the submission of new user data to the backend.

        Args:
            submission_data (Dict[str, Any]): The data to be submitted.
        """
        try:
            response: requests.Response = requests.post(cfg.SUBMIT_URL, json=submission_data)
            if response.status_code == 200:
                st.success("Data sent successfully.")
                with st.expander("Show/Close sent data"):
                    st.json(response.json())
                st.cache_data.clear()
            else:
                st.error("An error occurred while sending the data.")
                self.logger.info(submission_data)
                self.logger.info(f"Error {response.status_code}: {response.text}")
        except requests.exceptions.RequestException as e:
            st.error("Could not connect to the server.")
            self.logger.error(f"Connection error: {e}")
        
    def handle_prediction(self, data: Dict[str, Any]) -> None:
        try:
            response = requests.get(cfg.PREDICT_URL, params=data)
            response.raise_for_status()
            data = response.json()
            
            st.write("### Predicted Stress Level on your data")
            st.write(f"### The predicted stress level is: **{data['predicted_stress_level']}'**")
        except requests.RequestException as e:
            st.error(f"An error occuredwhile predicting: {e}")

    def run(self) -> None:
        """
        Run the frontend application by loading data, creating a graph generator,
        and displaying content.
        """
        data: pd.DataFrame = self.load_data()
        graph_generator: analyse.GenerateGraph = analyse.GenerateGraph(data)
        self.display_content(graph_generator)


if __name__ == "__main__":
    SleepDataFrontend()
